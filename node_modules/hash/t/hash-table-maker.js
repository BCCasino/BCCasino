/**
 *
 * How to use this hash-table generator: the script in this file isn't completely optimized for automated table building, but it's simple and clear enough
 * what to uncomment and what to comment out when switching between MD5 and SHA-256, ASCII and UTF-8 -- just make sure to look at all the lines that are
 * commented out before you get started!
 *
 *  (1) The first step generates a file of strings (string-samples.txt) that are between 0 and 42 characters long; the strings are contructed from random
 *  one char samples from the first 222 chars of the BigUTF-8.sample file or from the whole file depending on which version of the genVaildRand() method is
 *  enabled; (2) the calc_hashes continued method then spawns parallel child processes invoking the gawk | td | md5sum -or- sha256sum commands; each spawn is
 *  fed a string from the string-samples.txt file; (3) the callback routines (which happen per the continuation-passing mechanism) extract the 32/64 char
 *  long hash from stdout and build a an array of tuples with the original string and the "known good hash" produced with the Linux utilities; (4) the
 *  array is written out to a file named strings-and-hashes-MD5/SHA256.txt; (5) you will need to look through that file and escape the \ and ' and "
 *  characters within the string literals on the left-hand side of the tuples; I found it was pretty tricky to do with regex and ended up just doing a
 *  simple regex replacement, running my tests, and then cleaning up where the js engine was throwing exceptions on malformed strings. The simple regex's
 *  I used were:
 *
 *    ^(\[ '.*)\\(.*',) => \1\\\\\2
 *    ^(\[ '.*)"(.*',)  => \1\\"\2
 *    ^(\[ '.*)'(.*',)  => \1\\'\2
 *
 *  Make sure to do the one for \\ first!  I found that my editor of choice when working with these big texts (BBEdit) didn't pick up all the unescaped
 *  strings I wanted it to, but I gave up on more complex regex's and followed the steps described above; watch out especially for triple backslashes \\\
 *
**/

var sys = require('sys'),
    fs  = require('fs'),
    exec = require('child_process').exec

require('Task/Joose/Core')
require('Task/JooseX/Namespace/Depended/NodeJS')
require('Task/JooseX/CPS/All')

Joose.Module('StringerHasher', function (m) {

  body : {

  Class('Linux_Hasher', {

    trait : JooseX.CPS,

    has : {

      strings_and_hashes : {
        is : 'rw',
        init : Joose.I.Array
      }

    },

    continued : {

      methods : {

        calc_hashes : function (strings_array) {

          var cont = this.CONT
          var sAh = this.strings_and_hashes

          Joose.A.each(strings_array, function (str, index) {

            cont.AND(function () {

              var THROW    = this.getTHROW()
              var CONTINUE = this.getCONTINUE()

              // exec('gawk \'NR==' + (index + 1) + '\' string-samples.txt | tr -d \'\\r\' | tr -d \'\\n\' | md5sum' , // this will work for ASCII only strings
              // exec('gawk \'NR==' + (index + 1) + '\' string-samples.txt | tr -d \'\\r\' | tr -d \'\\n\' | md5sum -b' , // -b is needed for UTF-8 strings

              // exec('gawk \'NR==' + (index + 1) + '\' string-samples.txt | tr -d \'\\r\' | tr -d \'\\n\' | sha1sum' , // this will work for ASCII only strings
              // exec('gawk \'NR==' + (index + 1) + '\' string-samples.txt | tr -d \'\\r\' | tr -d \'\\n\' | sha1sum -b' , // -b is needed for UTF-8 strings

              // exec('gawk \'NR==' + (index + 1) + '\' string-samples.txt | tr -d \'\\r\' | tr -d \'\\n\' | sha256sum' , // this will work for ASCII only strings
              // exec('gawk \'NR==' + (index + 1) + '\' string-samples.txt | tr -d \'\\r\' | tr -d \'\\n\' | sha256sum -b' , // -b is needed for UTF-8 strings

              // exec('gawk \'NR==' + (index + 1) + '\' string-samples.txt | tr -d \'\\r\' | tr -d \'\\n\' | sha512sum' , // this will work for ASCII only strings
              // exec('gawk \'NR==' + (index + 1) + '\' string-samples.txt | tr -d \'\\r\' | tr -d \'\\n\' | sha512sum -b' , // -b is needed for UTF-8 strings

              exec('gawk \'NR==' + (index + 1) + '\' string-samples.txt | tr -d \'\\r\' | tr -d \'\\n\' | openssl dgst -rmd160' , // this will work for ASCII and UTF-8 strings

              function (error, stdout, stderr) {
                if (error != null) {
                  THROW(error)
                }
                else  {
                  CONTINUE(stdout, stderr, str)
                }
              }
            )

          })

          })

          cont.andTHEN(function () {

            Joose.A.each(arguments, function (result, index) {

              var stdout = result[0]
              var stderr = result[1]
              var str = result[2]

              // sAh.push([str, stdout.substring(0,32)]) // MD5 hashes are 32 chars long
              // sAh.push([str, stdout.substring(0,40)]) // SHA-1 hashes are 64 chars long
              // sAh.push([str, stdout.substring(0,64)]) // SHA-256 hashes are 64 chars long
              // sAh.push([str, stdout.substring(0,128)]) // SHA-512 hashes are 64 chars long
              sAh.push([str, stdout.substring(0,40)]) // RIPEMD-160 hashes are 64 chars long

            })

            this.CONTINUE(arguments)

          })

        }

      }

    }

  })

  var BigUTF8 = fs.readFileSync('./BigUTF-8.sample', 'UTF-8').split('')

  var genValidRand = function () {
    // var rand = Math.floor(Math.random() * 222) // up to 222 inclues ASCII characters only
    var rand = Math.floor(Math.random() * 75943)
    return rand
  }

  var genRandLength_lte100 = function () {
    return Math.floor(Math.random() * 42) // 42 <= a meet and just magic constant
  }

  var genRandString = function () {
    var length = genRandLength_lte100()
    var str = ''
    for (var i = 0 ; i < length ; i++) {
      var rand = genValidRand()
      var nc = BigUTF8[rand]
      str += nc
    }
    return str
  }

  var someStrings = []

  for (var j = 0 ; j < 5000 ; j++) {
    someStrings.push(genRandString())
  }

  var stringsdata = someStrings.join('\n')

  fs.writeFileSync('./string-samples.txt', stringsdata, 'UTF-8')

  var hasher = new StringerHasher.Linux_Hasher()

  hasher.calc_hashes(someStrings).FINALLY(function () {

    var tabledata = ''

    for (var g = 0 ; g < this.strings_and_hashes.length ; g++) {
      tabledata += '[ ' + '\'' + this.strings_and_hashes[g][0] + '\'' + ', ' + '\'' + this.strings_and_hashes[g][1] + '\'' + ' ],\n'
    }

    // fs.writeFileSync('./strings-and-hashes-MD5.txt', tabledata, 'UTF-8')
    // fs.writeFileSync('./strings-and-hashes-SHA1.txt', tabledata, 'UTF-8')
    // fs.writeFileSync('./strings-and-hashes-SHA256.txt', tabledata, 'UTF-8')
    // fs.writeFileSync('./strings-and-hashes-SHA512.txt', tabledata, 'UTF-8')
    fs.writeFileSync('./strings-and-hashes-RIPEMD160.txt', tabledata, 'UTF-8')

  }).now()

}

})

