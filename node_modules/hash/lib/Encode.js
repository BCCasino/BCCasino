/*//////////////////////////////////////////////////////////////////////////
 * THIS PROGRAM IS A DERIVATIVE OF AN EXISTING WORK :: 4 September 2010
 * See: http://pajhome.org.uk/crypt/md5/scripts.html
 *
 * Significant but mostly superficial changes have been made to the structure of the
 * source so that it conforms to the Joose3 object system for JavaScript
 * See: http://joose.it/
/*//////////////////////////////////////////////////////////////////////////


Class('Encode', {
    
    /*VERSION*/VERSION : 0.06,

  my : {    

    has : {

      /*
       * Configurable variables. You may need to tweak these to be compatible with
       * the server-side, but the defaults work in most cases.
       */
      hexcase : {
        is : 'rw',
        init : 0
      },
      
      b64pad : {
        is : 'rw',
        init : ''
      }

    },
    
    methods : {

      /*
       * Convert a raw string to a hex string
       */
      rstr2hex : function (input) {
        // try { this.getHexcase() } catch(e) { this.setHexcase(0) }
        var hex_tab = this.getHexcase() ? '0123456789ABCDEF' : '0123456789abcdef'
        var output = ''
        var x
        for(var i = 0; i < input.length; i++) {
         x = input.charCodeAt(i)
         output += hex_tab.charAt((x >>> 4) & 0x0F)
                +  hex_tab.charAt( x        & 0x0F)
        }
        return output
      },

      /*
       * Convert a raw string to a base-64 string
       */
      rstr2b64 : function (input) {
        // try { this.getB64pad() } catch(e) { this.setB64pad('') }
        var tab = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
        var output = ''
        var len = input.length
        for(var i = 0; i < len; i += 3) {
         var triplet = (input.charCodeAt(i) << 16)
                  | (i + 1 < len ? input.charCodeAt(i+1) << 8 : 0)
                  | (i + 2 < len ? input.charCodeAt(i+2)      : 0)
         for(var j = 0; j < 4; j++) {
           if(i * 8 + j * 6 > input.length * 8) output += b64pad
           else output += tab.charAt((triplet >>> 6*(3-j)) & 0x3F)
         }
        }
        return output
      },

      /*
       * Convert a raw string to an arbitrary string encoding
       */
      rstr2any : function (input, encoding) {
        var divisor = encoding.length
        var i, j, q, x, quotient
      
        /* Convert to an array of 16-bit big-endian values, forming the dividend */
        var dividend = Array(Math.ceil(input.length / 2))
        for(i = 0; i < dividend.length; i++) {
         dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1)
        }
      
        /*
         * Repeatedly perform a long division. The binary array forms the dividend,
         * the length of the encoding is the divisor. Once computed, the quotient
         * forms the dividend for the next step. All remainders are stored for later
         * use.
         */
        var full_length = Math.ceil(input.length * 8 / (Math.log(encoding.length) / Math.log(2)))
        var remainders = Array(full_length)
        for(j = 0; j < full_length; j++) {
         quotient = Array()
         x = 0
         for(i = 0; i < dividend.length; i++) {
           x = (x << 16) + dividend[i]
           q = Math.floor(x / divisor)
           x -= q * divisor
           if(quotient.length > 0 || q > 0)
            quotient[quotient.length] = q
         }
         remainders[j] = x
         dividend = quotient
        }
      
        /* Convert the remainders to the output string */
        var output = ''
        for(i = remainders.length - 1; i >= 0; i--)
         output += encoding.charAt(remainders[i])
      
        return output
      },

      /*
       * Encode a string as utf-8.
       * For efficiency, this assumes the input is valid utf-16.
       */
      str2rstr_utf8 : function (input) {
        var output = ''
        var i = -1
        var x, y
      
        while(++i < input.length) {
         /* Decode utf-16 surrogate pairs */
         x = input.charCodeAt(i)
         y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0
         if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF) {
           x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF)
           i++
         }
      
         /* Encode output as utf-8 */
         if(x <= 0x7F) {
           output += String.fromCharCode(x)
         }
         else if(x <= 0x7FF) {
           output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),
                                         0x80 | ( x         & 0x3F))
         }
         else if(x <= 0xFFFF) {
           output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
                                         0x80 | ((x >>> 6 ) & 0x3F),
                                         0x80 | ( x         & 0x3F))
         }
         else if(x <= 0x1FFFFF) {
           output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
                                         0x80 | ((x >>> 12) & 0x3F),
                                         0x80 | ((x >>> 6 ) & 0x3F),
                                         0x80 | ( x         & 0x3F))
         }
        }
        return output
      },

      /*
       * Encode a string as utf-16
       */
      str2rstr_utf16le : function (input) {
        var output = ''
        for(var i = 0; i < input.length; i++) {
           output += String.fromCharCode( input.charCodeAt(i)        & 0xFF,
                                         (input.charCodeAt(i) >>> 8) & 0xFF)
        }
        return output
      },
      
      str2rstr_utf16be : function (input) {
        var output = ''
        for(var i = 0; i < input.length; i++) {
         output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF,
                                        input.charCodeAt(i)        & 0xFF)
        }
        return output
      },

      /*
       * Convert a raw string to an array of little-endian words
       * Characters >255 have their high-byte silently ignored.
       */
      rstr2binl : function (input) {
        var output = Array(input.length >> 2)
        for(var i = 0; i < output.length; i++) {
          output[i] = 0
        }
        for(var i = 0; i < input.length * 8; i += 8) {
          output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (i%32)
        }
        return output
      },
      
      /*
       * Convert an array of little-endian words to a string
       */
      binl2rstr : function (input) {
        var output = ''
        for(var i = 0; i < input.length * 32; i += 8) {
         output += String.fromCharCode((input[i>>5] >>> (i % 32)) & 0xFF)
        }
        return output
      },

      /*
       * Convert a raw string to an array of big-endian words
       * Characters >255 have their high-byte silently ignored.
       */
      rstr2binb : function (input) {
        var output = Array(input.length >> 2)
        for(var i = 0; i < output.length; i++) {
          output[i] = 0
        }
        for(var i = 0; i < input.length * 8; i += 8) {
          output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (24 - i % 32)
        }
        return output
      },
      
      /*
       * Convert an array of big-endian words to a string
       */
      binb2rstr : function (input) {
        var output = ''
        for(var i = 0; i < input.length * 32; i += 8) {
          output += String.fromCharCode((input[i>>5] >>> (24 - i % 32)) & 0xFF)
        }
        return output
      }
        
    }

  }

})


/*///////////////////// ORIGINAL LICENSE BELOW ////////////////////////////////
 * Copyright (c) 1998 - 2009, Paul Johnston & Contributors
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *  * Neither the name of the <ORGANIZATION> nor the names of its contributors may
 *    be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
/*///////////////////////////////////////////////////////////////////////////
